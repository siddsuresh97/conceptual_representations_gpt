<!-- rownames(leuven_mds) <- leuven$X -->
<!-- leuven_mds <- leuven_mds[order(rownames(leuven_mds)),] -->
# leuven_data
rownames(leuven) = leuven$Unnamed..0
leuven = leuven[, 3:ncol(leuven)]
leuven = leuven[order(rownames(leuven)), order(colnames(leuven))]
# flan_verified_broad
rownames(flan_broad) = flan_broad$concept
flan_broad = flan_broad[, 2:ncol(flan_broad)]
flan_broad = flan_broad[order(rownames(flan_broad)), ]
# flan_verified_specific
rownames(flan_specific) = flan_specific$concept
flan_specific = flan_specific[, 2:ncol(flan_specific)]
flan_specific = flan_specific[order(rownames(flan_specific)), order(colnames(flan_specific))]
protest(leuven, flan_specific)
protest(as.matrix(leuven), as.matrix(flan_specific))
View(leuven)
View(flan_specific)
test = as.matrix(flan_specific)
View(test)
protest(as.numeric(as.matrix(leuven)), as.numeric(as.matrix(flan_specific)))
cat(is.na(leuven))
any(cat(is.na(leuven)))
if (any(cat(is.na(leuven)))) {
cat("At least one element in the matrix is TRUE.")
} else {
cat("No elements in the matrix are TRUE.")
}
if (any(is.na(leuven))) {
cat("At least one element in the matrix is TRUE.")
} else {
cat("No elements in the matrix are TRUE.")
}
if (any(is.na(flan_specific))) {
cat("At least one element in the matrix is TRUE.")
} else {
cat("No elements in the matrix are TRUE.")
}
#libraries
library(lsa)
library(vegan)
library(ape)
library(psych)
library(ggplot2)
library(dendextend)
library(circlize)
library(grid)
library(tidyr)
# feature list humans (leuven) vs feature list flan
# set working dir to the dir the script is in
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
leuven =read.csv('data/leuven/leuven_norms.csv')
#libraries
library(lsa)
library(vegan)
library(ape)
library(psych)
library(ggplot2)
library(dendextend)
library(circlize)
library(grid)
library(tidyr)
# feature list humans (leuven) vs feature list flan
# set working dir to the dir the script is in
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
leuven =read.csv('data/leuven/leuven_norms.csv')
# leuven_data
rownames(leuven) = leuven$Unnamed..0
leuven = leuven[, 3:ncol(leuven)]
leuven = leuven[order(rownames(leuven)), order(colnames(leuven))]
#leuven_data
leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE)
leuven[is.na(leuven)] = 0
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,2:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
rownames(leuven_cosine_dist) <- leuven$X
rownames(leuven_mds) <- leuven$X
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
# flan_verified_broad
rownames(flan_broad) = flan_broad$concept
flan_broad = flan_broad[, 2:ncol(flan_broad)]
flan_broad = flan_broad[order(rownames(flan_broad)), ]
# flan_verified_specific
rownames(flan_specific) = flan_specific$concept
flan_specific = flan_specific[, 2:ncol(flan_specific)]
flan_specific = flan_specific[order(rownames(flan_specific)), order(colnames(flan_specific))]
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,2:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
rownames(flan_specific_cosine_dist) <- flan_specific$concept
rownames(flan_specific_mds) <- flan_specific$concept
flan_specific_mds <- flan_specific_mds[order(rownames(flan_specific_mds)),]
View(leuven_mds)
View(flan_broad)
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,1:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
rownames(flan_specific_cosine_dist) <- flan_specific$concept
rownames(flan_specific_mds) <- flan_specific$concept
flan_specific_mds <- flan_specific_mds[order(rownames(flan_specific_mds)),]
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,1:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
<!-- rownames(flan_specific_cosine_dist) <- flan_specific$concept -->
<!-- rownames(flan_specific_mds) <- flan_specific$concept -->
flan_specific_mds <- flan_specific_mds[order(rownames(flan_specific_mds)),]
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
leuven =read.csv('data/leuven/leuven_norms.csv')
# leuven_data
rownames(leuven) = leuven$Unnamed..0
leuven = leuven[, 3:ncol(leuven)]
leuven = leuven[order(rownames(leuven)), order(colnames(leuven))]
#leuven_data
<!-- leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE) -->
<!-- leuven[is.na(leuven)] = 0 -->
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,1:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
<!-- rownames(leuven_cosine_dist) <- leuven$X -->
<!-- rownames(leuven_mds) <- leuven$X -->
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
# flan_verified_broad
rownames(flan_broad) = flan_broad$concept
flan_broad = flan_broad[, 2:ncol(flan_broad)]
flan_broad = flan_broad[order(rownames(flan_broad)), ]
# flan_verified_specific
rownames(flan_specific) = flan_specific$concept
flan_specific = flan_specific[, 2:ncol(flan_specific)]
flan_specific = flan_specific[order(rownames(flan_specific)), order(colnames(flan_specific))]
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,1:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
<!-- rownames(flan_specific_cosine_dist) <- flan_specific$concept -->
<!-- rownames(flan_specific_mds) <- flan_specific$concept -->
flan_specific_mds <- flan_specific_mds[order(rownames(flan_specific_mds)),]
#flan_verified broad
flan_broad_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_broad[,1:ncol(flan_broad)])))
flan_broad_mds <- cmdscale(flan_broad_cosine_dist,k = 3)
<!-- rownames(flan_broad_cosine_dist) <- flan_broad$concept -->
<!-- rownames(flan_broad_mds) <- flan_broad$concept -->
flan_broad_mds <- flan_broad_mds[order(rownames(flan_broad_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, flan_specific_mds, flan_broad_mds)
<!-- matrices = list(leuven, flan_specific, flan_broad) -->
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan_specific", "flan_broad")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
<!-- df <- apply(protest_results,2,as.character) -->
View(matrix_combinations)
View(matrix_combinations)
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan_specific", "flan_broad")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
<!-- df <- apply(protest_results,2,as.character) -->
View(protest_results)
#leuven_data
<!-- leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE) -->
<!-- leuven[is.na(leuven)] = 0 -->
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,1:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 2026)
<!-- rownames(leuven_cosine_dist) <- leuven$X -->
<!-- rownames(leuven_mds) <- leuven$X -->
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
View(leuven_cosine_dist)
cor(leuven, flan_specific)
cor(as.numeric(leuven), as.numeric(flan_specific))
class(leuven)
View(protest_results)
#libraries
library(lsa)
library(vegan)
library(ape)
library(psych)
library(ggplot2)
library(dendextend)
library(circlize)
library(grid)
library(tidyr)
# feature list humans (leuven) vs feature list flan
# set working dir to the dir the script is in
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
leuven =read.csv('data/leuven/leuven_norms.csv')
# leuven_data
rownames(leuven) = leuven$Unnamed..0
leuven = leuven[, 3:ncol(leuven)]
leuven = leuven[order(rownames(leuven)), order(colnames(leuven))]
#leuven_data
<!-- leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE) -->
<!-- leuven[is.na(leuven)] = 0 -->
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,1:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
<!-- rownames(leuven_cosine_dist) <- leuven$X -->
<!-- rownames(leuven_mds) <- leuven$X -->
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
# flan_verified_broad
rownames(flan_broad) = flan_broad$concept
flan_broad = flan_broad[, 2:ncol(flan_broad)]
flan_broad = flan_broad[order(rownames(flan_broad)), ]
# flan_verified_specific
rownames(flan_specific) = flan_specific$concept
flan_specific = flan_specific[, 2:ncol(flan_specific)]
flan_specific = flan_specific[order(rownames(flan_specific)), order(colnames(flan_specific))]
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,1:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
<!-- rownames(flan_specific_cosine_dist) <- flan_specific$concept -->
<!-- rownames(flan_specific_mds) <- flan_specific$concept -->
flan_specific_mds <- flan_specific_mds[order(rownames(flan_specific_mds)),]
#flan_verified broad
flan_broad_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_broad[,1:ncol(flan_broad)])))
flan_broad_mds <- cmdscale(flan_broad_cosine_dist,k = 3)
<!-- rownames(flan_broad_cosine_dist) <- flan_broad$concept -->
<!-- rownames(flan_broad_mds) <- flan_broad$concept -->
flan_broad_mds <- flan_broad_mds[order(rownames(flan_broad_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, flan_specific_mds, flan_broad_mds)
<!-- matrices = list(leuven, flan_specific, flan_broad) -->
## Create an empty list to store the results
results = list()
<!-- ## Iterate through all combinations of the matrices -->
<!-- for (i in 1:(length(matrices))) { -->
<!--     for (j in 1:(length(matrices))) { -->
<!--         # Pass the two matrices to the protest function and store the result -->
<!--         result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE) -->
<!--         results = c(results, sqrt(1-result$ss)) -->
<!--     } -->
<!-- } -->
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = corr(matrices[[i]], matrices[[j]])
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan_specific", "flan_broad")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
<!-- df <- apply(protest_results,2,as.character) -->
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
leuven =read.csv('data/leuven/leuven_norms.csv')
# leuven_data
rownames(leuven) = leuven$Unnamed..0
leuven = leuven[, 3:ncol(leuven)]
leuven = leuven[order(rownames(leuven)), order(colnames(leuven))]
#leuven_data
<!-- leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE) -->
<!-- leuven[is.na(leuven)] = 0 -->
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,1:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
<!-- rownames(leuven_cosine_dist) <- leuven$X -->
<!-- rownames(leuven_mds) <- leuven$X -->
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
# flan_verified_broad
rownames(flan_broad) = flan_broad$concept
flan_broad = flan_broad[, 2:ncol(flan_broad)]
flan_broad = flan_broad[order(rownames(flan_broad)), ]
# flan_verified_specific
rownames(flan_specific) = flan_specific$concept
flan_specific = flan_specific[, 2:ncol(flan_specific)]
flan_specific = flan_specific[order(rownames(flan_specific)), order(colnames(flan_specific))]
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,1:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
<!-- rownames(flan_specific_cosine_dist) <- flan_specific$concept -->
<!-- rownames(flan_specific_mds) <- flan_specific$concept -->
flan_specific_mds <- flan_specific_mds[order(rownames(flan_specific_mds)),]
#flan_verified broad
flan_broad_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_broad[,1:ncol(flan_broad)])))
flan_broad_mds <- cmdscale(flan_broad_cosine_dist,k = 3)
<!-- rownames(flan_broad_cosine_dist) <- flan_broad$concept -->
<!-- rownames(flan_broad_mds) <- flan_broad$concept -->
flan_broad_mds <- flan_broad_mds[order(rownames(flan_broad_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, flan_specific_mds, flan_broad_mds)
<!-- matrices = list(leuven, flan_specific, flan_broad) -->
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = corr(matrices[[i]], matrices[[j]])
results = c(results, sqrt(1-result$ss))
}
}
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan_specific", "flan_broad")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
View(protest_results)
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
leuven =read.csv('data/leuven/leuven_norms.csv')
flan_overlap = read.csv('data/leuven/flan_leuven_norms_overlap.csv')
# flan_overlap
rownames(flan_overlap) = flan_overlap$concept
flan_overlap = flan_overlap[, 2:ncol(flan_overlap)]
flan_overlap = flan_overlap[order(rownames(flan_overlap)), order(colnames(flan_overlap))]
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
leuven =read.csv('data/leuven/leuven_norms.csv')
flan_overlap = read.csv('data/leuven/flan_leuven_norms_overlap.csv')
# flan_overlap
rownames(flan_overlap) = flan_overlap$concept
flan_overlap = flan_overlap[, 2:ncol(flan_overlap)]
flan_overlap = flan_overlap[order(rownames(flan_overlap)), order(colnames(flan_overlap))]
# flan_overlap
flan_overlap_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_overlap[,1:ncol(flan_overlap)])))
flan_overlap_mds <- cmdscale(flan_overlap_cosine_dist,k = 3)
flan_overlap_mds <- flan_overlap_mds[order(rownames(flan_overlap_mds)),]
View(flan_overlap)
View(flan_specific)
# flan_verified_specific
rownames(flan_specific) = flan_specific$concept
flan_specific = flan_specific[, 2:ncol(flan_specific)]
flan_specific = flan_specific[order(rownames(flan_specific)), order(colnames(flan_specific))]
# flan_overlap
rownames(flan_overlap) = flan_overlap$concept
flan_overlap = flan_overlap[, 2:ncol(flan_overlap)]
flan_overlap = flan_overlap[order(rownames(flan_overlap)), order(colnames(flan_overlap))]
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,1:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
<!-- rownames(flan_specific_cosine_dist) <- flan_specific$concept -->
<!-- rownames(flan_specific_mds) <- flan_specific$concept -->
flan_specific_mds <- flan_specific_mds[order(rownames(flan_specific_mds)),]
#flan_verified broad
flan_broad_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_broad[,1:ncol(flan_broad)])))
flan_broad_mds <- cmdscale(flan_broad_cosine_dist,k = 3)
<!-- rownames(flan_broad_cosine_dist) <- flan_broad$concept -->
<!-- rownames(flan_broad_mds) <- flan_broad$concept -->
flan_broad_mds <- flan_broad_mds[order(rownames(flan_broad_mds)),]
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
leuven =read.csv('data/leuven/leuven_norms.csv')
flan_overlap = read.csv('data/leuven/flan_leuven_norms_overlap.csv')
# leuven_data
rownames(leuven) = leuven$Unnamed..0
leuven = leuven[, 3:ncol(leuven)]
leuven = leuven[order(rownames(leuven)), order(colnames(leuven))]
#leuven_data
<!-- leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE) -->
<!-- leuven[is.na(leuven)] = 0 -->
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,1:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
<!-- rownames(leuven_cosine_dist) <- leuven$X -->
<!-- rownames(leuven_mds) <- leuven$X -->
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
# flan_verified_broad
rownames(flan_broad) = flan_broad$concept
flan_broad = flan_broad[, 2:ncol(flan_broad)]
flan_broad = flan_broad[order(rownames(flan_broad)), ]
# flan_verified_specific
rownames(flan_specific) = flan_specific$concept
flan_specific = flan_specific[, 2:ncol(flan_specific)]
flan_specific = flan_specific[order(rownames(flan_specific)), order(colnames(flan_specific))]
# flan_overlap
rownames(flan_overlap) = flan_overlap$concept
flan_overlap = flan_overlap[, 2:ncol(flan_overlap)]
flan_overlap = flan_overlap[order(rownames(flan_overlap)), order(colnames(flan_overlap))]
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,1:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
<!-- rownames(flan_specific_cosine_dist) <- flan_specific$concept -->
<!-- rownames(flan_specific_mds) <- flan_specific$concept -->
flan_specific_mds <- flan_specific_mds[order(rownames(flan_specific_mds)),]
#flan_verified broad
flan_broad_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_broad[,1:ncol(flan_broad)])))
flan_broad_mds <- cmdscale(flan_broad_cosine_dist,k = 3)
<!-- rownames(flan_broad_cosine_dist) <- flan_broad$concept -->
<!-- rownames(flan_broad_mds) <- flan_broad$concept -->
flan_broad_mds <- flan_broad_mds[order(rownames(flan_broad_mds)),]
# flan_overlap
flan_overlap_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_overlap[,1:ncol(flan_overlap)])))
flan_overlap_mds <- cmdscale(flan_overlap_cosine_dist,k = 3)
flan_overlap_mds <- flan_overlap_mds[order(rownames(flan_overlap_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, flan_specific_mds, flan_broad_mds, flan_overlap_mds)
<!-- matrices = list(leuven, flan_specific, flan_broad) -->
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan_specific", "flan_broad", "flan_overlap")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
View(protest_results)
