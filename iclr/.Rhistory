#libraries
library(lsa)
library(vegan)
library(ape)
library(psych)
library(ggplot2)
library(dendextend)
library(circlize)
library(grid)
library(tidyr)
# feature list humans (leuven) vs feature list flan
# set working dir to the dir the script is in
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan = read.csv('data/leuven/flan_leuven_norms.csv')
#leuven_data
leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE)
leuven[is.na(leuven)] = 0
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,2:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
rownames(leuven_cosine_dist) <- leuven$X
rownames(leuven_mds) <- leuven$X
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
flan_cosine_dist[,2:ncol(flan_cosine_dist)]
t(data.matrix(flan[,2:ncol(flan)])
)
View(flan)
View(flan)
#leuven_data
leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE)
leuven[is.na(leuven)] = 0
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,2:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
rownames(leuven_cosine_dist) <- leuven$X
rownames(leuven_mds) <- leuven$X
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
#flan_verified
flan_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan[,2:ncol(flan)])))
flan_mds <- cmdscale(flan_cosine_dist,k = 3)
rownames(flan_cosine_dist) <- flan$concept
rownames(flan_mds) <- flan$concept
flan_mds <- flan_mds[order(rownames(flan_mds)),]
View(leuven_mds)
View(leuven_mds)
View(flan_mds)
# pairwise protest all elements
matrices = list(leuven_mds, flan_mds)
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
<!-- df <- apply(protest_results,2,as.character) -->
View(protest_results)
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
#leuven_data
leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE)
leuven[is.na(leuven)] = 0
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,2:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
rownames(leuven_cosine_dist) <- leuven$X
rownames(leuven_mds) <- leuven$X
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
#flan_verified
flan_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan[,2:ncol(flan)])))
flan_mds <- cmdscale(flan_cosine_dist,k = 3)
rownames(flan_cosine_dist) <- flan$concept
rownames(flan_mds) <- flan$concept
flan_mds <- flan_mds[order(rownames(flan_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, flan_mds)
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
<!-- df <- apply(protest_results,2,as.character) -->
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
#leuven_data
leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE)
leuven[is.na(leuven)] = 0
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,2:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
rownames(leuven_cosine_dist) <- leuven$X
rownames(leuven_mds) <- leuven$X
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,2:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
rownames(flan_specific_cosine_dist) <- flan_specific$concept
rownames(flan_specific_mds) <- flan_specific$concept
flan_specific_mds <- flan_specific_mds[order(rownames(flan_mds)),]
#flan_verified broad
flan_broad_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_broad[,2:ncol(flan_broad)])))
flan_broad_mds <- cmdscale(flan_broad_cosine_dist,k = 3)
rownames(flan_broad_cosine_dist) <- flan_broad$concept
rownames(flan_broad_mds) <- flan_broad$concept
flan_broad_mds <- flan_broad_mds[order(rownames(flan_broad_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, flan_mds)
## Create an empty list to store the results
results = list()
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
#leuven_data
leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE)
leuven[is.na(leuven)] = 0
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,2:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
rownames(leuven_cosine_dist) <- leuven$X
rownames(leuven_mds) <- leuven$X
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,2:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
rownames(flan_specific_cosine_dist) <- flan_specific$concept
rownames(flan_specific_mds) <- flan_specific$concept
flan_specific_mds <- flan_specific_mds[order(rownames(flan_mds)),]
#flan_verified broad
flan_broad_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_broad[,2:ncol(flan_broad)])))
flan_broad_mds <- cmdscale(flan_broad_cosine_dist,k = 3)
rownames(flan_broad_cosine_dist) <- flan_broad$concept
rownames(flan_broad_mds) <- flan_broad$concept
flan_broad_mds <- flan_broad_mds[order(rownames(flan_broad_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, flan_specific_mds, flan_broad_mds)
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
<!-- df <- apply(protest_results,2,as.character) -->
View(protest_results)
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan_specific", "flan_broad")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
View(protest_results)
# pairwise protest all elements
matrices = list(leuven_mds, flan_specific_mds, flan_broad_mds)
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan_specific", "flan_broad")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
<!-- df <- apply(protest_results,2,as.character) -->
View(protest_results)
# Load data
leuven_animals = read.csv('data/leuven/animal_leuven_norms.csv')
leuven_tools = read.csv('data/leuven/artifacts_leuven_norms.csv')
flan_broad = read.csv('data/leuven/flan_leuven_norms_broad_prompt.csv')
flan_specific = read.csv('data/leuven/flan_leuven_norms.csv')
#leuven_data
leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE)
leuven[is.na(leuven)] = 0
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,2:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
rownames(leuven_cosine_dist) <- leuven$X
rownames(leuven_mds) <- leuven$X
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,2:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
rownames(flan_specific_cosine_dist) <- flan_specific$concept
rownames(flan_specific_mds) <- flan_specific$concept
flan_specific_mds <- flan_specific_mds[order(rownames(flan_mds)),]
#flan_verified broad
flan_broad_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_broad[,2:ncol(flan_broad)])))
flan_broad_mds <- cmdscale(flan_broad_cosine_dist,k = 3)
rownames(flan_broad_cosine_dist) <- flan_broad$concept
rownames(flan_broad_mds) <- flan_broad$concept
flan_broad_mds <- flan_broad_mds[order(rownames(flan_broad_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, flan_specific_mds, flan_broad_mds)
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan_specific", "flan_broad")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
<!-- df <- apply(protest_results,2,as.character) -->
View(protest_results)
#flan_verified
flan_specific_cosine_dist = 1-  lsa::cosine(t(data.matrix(flan_specific[,2:ncol(flan_specific)])))
flan_specific_mds <- cmdscale(flan_specific_cosine_dist,k = 3)
rownames(flan_specific_cosine_dist) <- flan_specific$concept
rownames(flan_specific_mds) <- flan_specific$concept
flan_specific_mds <- flan_specific_mds[order(rownames(flan_specific_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, flan_specific_mds, flan_broad_mds)
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "flan_specific", "flan_broad")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
<!-- df <- apply(protest_results,2,as.character) -->
View(protest_results)
