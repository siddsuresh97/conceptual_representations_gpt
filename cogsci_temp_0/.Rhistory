#flan_verified
flan_verified = read.csv('data/feature_listing/flan_wide.csv')
flan_dsm = 1-  lsa::cosine(t(data.matrix(flan_verified[,2:ncol(flan_verified)])))
flan_mds <- cmdscale(flan_dsm,k = 3)
rownames(flan_dsm) <- flan_verified$Concept
rownames(flan_mds) = rownames(flan_mds)
flan_mds <- flan_mds[order(rownames(flan_mds)),]
View(flan_verified)
View(flan_mds)
View(flan_dsm)
#flan_verified
flan_verified = read.csv('data/feature_listing/flan_wide.csv')
flan_dsm = 1-  lsa::cosine(t(data.matrix(flan_verified[,2:ncol(flan_verified)])))
flan_mds <- cmdscale(flan_dsm,k = 3)
rownames(flan_dsm) <- flan_verified$Concept
rownames(flan_mds) = rownames(flan_dsm)
flan_mds <- flan_mds[order(rownames(flan_mds)),]
#libraries
library(lsa)
library(vegan)
library(ape)
library(psych)
library(ggplot2)
library(dendextend)
library(circlize)
library(grid)
library(tidyr)
# feature list humans (leuven) vs feature list gpt
# set working dir to the dir the script is in
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Load data
leuven_animals = read.csv('data/feature_listing/animal_leuven_norms.csv')
leuven_tools = read.csv('data/feature_listing/artifacts_leuven_norms.csv')
clip = read.csv('data/clip/clip_embeddings.csv')
w2v = read.csv('data/word2vec/word2vec_embeddings.csv')
human_triplet_mds = read.csv('data/triplets/summer_data/human_reptile_tool_embedding_df.csv')
gpt_triplet_mds = read.csv('data/triplets/summer_data/gpt_reptile_tool_embedding_df_temp0_cogsci2023.csv')
gpt_embed <- read.csv('data/gpt/gpt_embeddings_text-similarity-davinci-001.csv')
# clip_data
clip = clip[order(clip$X), ]
clip_dsm =1-lsa::cosine(t(data.matrix(clip[,2:ncol(clip)])))
clip_mds =  cmdscale(clip_dsm,k = 3)
rownames(clip_dsm) <- clip$X
rownames(clip_mds) <- clip$X
clip_mds <- clip_mds[order(rownames(clip_mds)),]
# gpt_embed_data
gpt_embed = gpt_embed[order(gpt_embed$X), ]
gpt_embed_dsm =1-lsa::cosine(t(data.matrix(gpt_embed[,2:ncol(gpt_embed)])))
gpt_embed_mds =  cmdscale(gpt_embed_dsm,k = 3)
rownames(gpt_embed_dsm) <- gpt_embed$X
rownames(gpt_embed_mds) <- gpt_embed$X
gpt_embed_mds <- gpt_embed_mds[order(rownames(gpt_embed_mds)),]
#word2vec_data
w2v = w2v[order(w2v$X), ]
w2v_dsm =1-lsa::cosine(t(data.matrix(w2v[,2:ncol(w2v)])))
<!-- w2v_dsm = dist(w2v[,2:ncol(w2v)) -->
w2v_mds =  cmdscale(w2v_dsm,k = 3)
rownames(w2v_dsm) <- w2v$X
rownames(w2v_mds) <- w2v$X
w2v_mds <- w2v_mds[order(rownames(w2v_mds)),]
#leuven_data
leuven = merge(leuven_animals, leuven_tools, by = 'X', all = TRUE)
leuven[is.na(leuven)] = 0
leuven_cosine_dist = 1-  lsa::cosine(t(data.matrix(leuven[,2:ncol(leuven)])))
leuven_mds <- cmdscale(leuven_cosine_dist,k = 3)
rownames(leuven_cosine_dist) <- leuven$X
rownames(leuven_mds) <- leuven$X
leuven_mds <- leuven_mds[order(rownames(leuven_mds)),]
#flan_verified
flan_verified = read.csv('data/feature_listing/flan_wide.csv')
flan_dsm = 1-  lsa::cosine(t(data.matrix(flan_verified[,2:ncol(flan_verified)])))
flan_mds <- cmdscale(flan_dsm,k = 3)
rownames(flan_dsm) <- flan_verified$Concept
rownames(flan_mds) = rownames(flan_dsm)
flan_mds <- flan_mds[order(rownames(flan_mds)),]
#gpt unverified
gpt_summer_no_mc = read.csv('data/feature_listing/gpt_response_unverified_wide_no_matrix_completion.csv')
unverified_gpt_dsm = 1-  lsa::cosine(t(data.matrix(gpt_summer_no_mc[,2:ncol(gpt_summer_no_mc)])))
unverified_gpt_mds_summer_no_mc <- cmdscale(unverified_gpt_dsm,k = 3)
rownames(unverified_gpt_dsm) <- gpt_summer_no_mc$Concept
rownames(unverified_gpt_mds_summer_no_mc) = rownames(unverified_gpt_dsm)
unverified_gpt_mds_summer_no_mc <- unverified_gpt_mds_summer_no_mc[order(rownames(unverified_gpt_mds_summer_no_mc)),]
# gpt verified
gpt_summer_no_mc = read.csv('data/feature_listing/gpt_response_yes_wide_no_matrix_completion.csv')
verified_gpt_dsm = 1-  lsa::cosine(t(data.matrix(gpt_summer_no_mc[,2:ncol(gpt_summer_no_mc)])))
verified_gpt_mds_summer_no_mc <- cmdscale(verified_gpt_dsm,k = 3)
rownames(verified_gpt_dsm) <- gpt_summer_no_mc$Concept
rownames(verified_gpt_mds_summer_no_mc) = rownames(verified_gpt_dsm)
verified_gpt_mds_summer_no_mc <- verified_gpt_mds_summer_no_mc[order(rownames(verified_gpt_mds_summer_no_mc)),]
# human triplets
rownames(human_triplet_mds) <- human_triplet_mds$concept
human_triplet_mds <- human_triplet_mds[order(rownames(human_triplet_mds)),]
human_triplet_mds <- human_triplet_mds[, 3:5]
human_triplet_cosine_dist = 1-  lsa::cosine(t(data.matrix(human_triplet_mds)))
rownames(human_triplet_cosine_dist) <- human_triplet_mds$concept
# gpt triplets
rownames(gpt_triplet_mds) <- gpt_triplet_mds$concept
gpt_triplet_mds <- gpt_triplet_mds[order(rownames(gpt_triplet_mds)),]
gpt_triplet_mds <- gpt_triplet_mds[, 3:5]
gpt_triplet_cosine_dist = 1-  lsa::cosine(t(data.matrix(gpt_triplet_mds)))
rownames(gpt_triplet_cosine_dist) <- gpt_triplet_mds$concept
# pairwise protest all elements
matrices = list(leuven_mds, w2v_mds, clip_mds, unverified_gpt_mds_summer_no_mc, verified_gpt_mds_summer_no_mc, human_triplet_mds, gpt_triplet_mds, gpt_embed_mds, flan_mds)
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "w2v", "clip", "unverified_gpt_summer_no_mc", "verified_gpt_summer_no_mc", "human_triplet", "gpt_triplet", "gpt_embed_mds", "flan_mds")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
View(protest_results)
View(flan_mds)
View(unverified_gpt_dsm)
View(unverified_gpt_mds_summer_no_mc)
#flan_verified
flan_verified = read.csv('data/feature_listing/flan_wide.csv')
flan_dsm = 1-  lsa::cosine(t(data.matrix(flan_verified[,2:ncol(flan_verified)])))
flan_mds <- cmdscale(flan_dsm,k = 3)
rownames(flan_dsm) <- flan_verified$Concept
rownames(flan_mds) = rownames(flan_dsm)
flan_mds <- flan_mds[order(rownames(flan_mds)),]
#flan_verified
flan_verified = read.csv('data/feature_listing/flan_wide.csv')
flan_dsm = 1-  lsa::cosine(t(data.matrix(flan_verified[,2:ncol(flan_verified)])))
flan_mds <- cmdscale(flan_dsm,k = 3)
rownames(flan_dsm) <- flan_verified$Concept
rownames(flan_mds) = rownames(flan_dsm)
flan_mds <- flan_mds[order(rownames(flan_mds)),]
#flan_verified
flan_verified = read.csv('data/feature_listing/flan_wide.csv')
flan_dsm = 1-  lsa::cosine(t(data.matrix(flan_verified[,2:ncol(flan_verified)])))
flan_mds <- cmdscale(flan_dsm,k = 3)
rownames(flan_dsm) <- flan_verified$Concept
rownames(flan_mds) = rownames(flan_dsm)
flan_mds <- flan_mds[order(rownames(flan_mds)),]
View(flan_mds)
# pairwise protest all elements
matrices = list(leuven_mds, w2v_mds, clip_mds, unverified_gpt_mds_summer_no_mc, verified_gpt_mds_summer_no_mc, human_triplet_mds, gpt_triplet_mds, gpt_embed_mds, flan_mds)
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "w2v", "clip", "unverified_gpt_summer_no_mc", "verified_gpt_summer_no_mc", "human_triplet", "gpt_triplet", "gpt_embed_mds", "flan_mds")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
View(protest_results)
View(protest_results)
#flan_xxl_verified
flan_xxl_verified = read.csv('data/feature_listing/flan_xxl_wide.csv')
flan_xxl_dsm = 1-  lsa::cosine(t(data.matrix(flan_xxl_verified[,2:ncol(flan_xxl_verified)])))
flan_xxl_mds <- cmdscale(flan_xxl_dsm,k = 3)
rownames(flan_xxl_dsm) <- flan_xxl_verified$Concept
rownames(flan_xxl_mds) = rownames(flan_xxl_dsm)
flan_xxl_mds <- flan_xxl_mds[order(rownames(flan_xxl_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, w2v_mds, clip_mds, unverified_gpt_mds_summer_no_mc, verified_gpt_mds_summer_no_mc, human_triplet_mds, gpt_triplet_mds, gpt_embed_mds, flan_xl_mds, flan_xxl_mds)
## Create an empty list to store the results
results = list()
#flan_xl_verified
flan_xl_verified = read.csv('data/feature_listing/flan_xl_wide.csv')
flan_xl_dsm = 1-  lsa::cosine(t(data.matrix(flan_xl_verified[,2:ncol(flan_xl_verified)])))
flan_xl_mds <- cmdscale(flan_xl_dsm,k = 3)
rownames(flan_xl_dsm) <- flan_xl_verified$Concept
rownames(flan_xl_mds) = rownames(flan_xl_dsm)
flan_xl_mds <- flan_xl_mds[order(rownames(flan_xl_mds)),]
# pairwise protest all elements
matrices = list(leuven_mds, w2v_mds, clip_mds, unverified_gpt_mds_summer_no_mc, verified_gpt_mds_summer_no_mc, human_triplet_mds, gpt_triplet_mds, gpt_embed_mds, flan_xl_mds, flan_xxl_mds)
## Create an empty list to store the results
results = list()
## Iterate through all combinations of the matrices
for (i in 1:(length(matrices))) {
for (j in 1:(length(matrices))) {
# Pass the two matrices to the protest function and store the result
result = protest(matrices[[i]], matrices[[j]], symmetric=TRUE)
results = c(results, sqrt(1-result$ss))
}
}
## make the results into a table
## Create a data frame with all possible combinations of matrix names
matrix_names = list("leuven", "w2v", "clip", "unverified_gpt_summer_no_mc", "verified_gpt_summer_no_mc", "human_triplet", "gpt_triplet", "gpt_embed_mds", "flan_xl_mds", "flan_xxl_mds")
matrix_combinations = expand.grid(matrix_names, matrix_names)
## Assign column names to the data frame
colnames(matrix_combinations) = c("matrix1", "matrix2")
## Fill in the values
k = 1
for (i in 1:length(matrix_names)) {
for (j in 1:length(matrix_names)) {
matrix_combinations[k, "result"] = results[k]
k = k + 1
}
}
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
View(protest_results)
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
write.csv(protest_results, "results/correlation_table.csv")
class(protest_results)
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
write.csv(data.frame(protest_results), "results/correlation_table.csv")
protest_results
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
write.csv(as.data.frame(protest_results), "results/correlation_table.csv")
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
library(tibble)
write_csv(protest_results, "results/correlation_table.csv")
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
library(tibble)
write.csv(protest_results, "results/correlation_table.csv")
protest_results
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
write.table(protest_results, "results/correlation_table.csv")
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
write.table(as.matrix(protest_results), "results/correlation_table.csv")
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
write.table(protest_results, "results/correlation_table.csv")
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
df <- apply(protest_results,2,as.character)
write.table(df, "results/correlation_table.csv")
write.table(data.frame(df), "results/correlation_table.csv")
write.table(data.frame(df), "results/correlation_table")
protest_results =  pivot_wider(matrix_combinations, names_from = matrix1, values_from = result)
<!-- df <- apply(protest_results,2,as.character) -->
write.table(data.frame(df), "results/correlation_table.csv")
write.table(data.frame(df), "results/correlation_table.csv", sep=",")
View(protest_results)
